clientNode{
    int limit;
    string bit_string;
    [string, node] nestedMap;

    /* [0, 1, 2, 3, 4, 5][succ0, succ1, pred0, pred1][node] */
    /* [0_succ0, 0_succ1, 0_pred0, 0_pred1]*/

    init() {
        limit = 5;
        bit_string= bitfolge(id(this), limit);
        int currentLevel;
        for(currentLevel = 0; currentLevel < limit; currentLevel++) {
            nestedMap[currentLevel + "_succ0"] = null;
            nestedMap[currentLevel + "_succ1"] = null;
            nestedMap[currentLevel + "_pred0"] = null;
            nestedMap[currentLevel + "_pred1"] = null;    
        }
    }

    timeout() {
        print("timeout");
    }
    linearize(node v){
        print("linearize");
    }

    entry(node C) {
        linearize(C);
    }

    bitfolge string (int x, int max) {
        int prime = 97;
        int res = (x * 37 + 17) % prime;
        int bit = 0;
        string bits = "";
        int i = 0;
        for (i=0; i<max; i++){
            bit = res%2;
            if (bit == 1){
                bits = "1" + bits;
            }
            else {
                bits = "0" + bits;
            }
        }
        return bits;
    }

    min_pred node (int level){
        node pred0;
        node pred1;

        pred0 = nestedMap[level + "_pred0"];
        pred1 = nestedMap[level + "_pred1"];  
        
        node minPred;
        if(id(pred0) < id(pred1)){
            minPred = pred0;
        } else {
            minPred = pred1;
        }
        print("min pred" + id(minPred));
        return minPred;
    }

    max_succ node (int level){
        node succ0;
        node succ1;

        succ0 = nestedMap[level + "_succ0"];
        succ1 = nestedMap[level + "_succ1"];  
        
        node maxSucc;
        if(id(succ0) > id(succ1)){
            maxSucc = succ0;
        } else {
            maxSucc = succ1;
        }
        print("max succ" + id(maxSucc));
        return maxSucc;
    }
/* Folie 169, zu allen Ni Kanten erstellen, Wie?, Ni enthält mehr Knoten als die nested map mit den vorgängern/nachfolgern oder???) */

    
}
