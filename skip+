succPredListclientNode{
    int limit = 5;
    string bitString;
    bool deleted = false;
    [string, node] succPredList; /* [level_succ/predBit, node] */
    [string, node] neighbors;  /*[bitstring, node]*/
    [string, node] toBeDeleted blue; /*darf nicht als Kante angezeigt werden*/
    node[] tempArray;

    /* [0, 1, 2, 3, 4, 5][succ0, succ1, pred0, pred1][node] */
    /* [0_succ0, 0_succ1, 0_pred0, 0_pred1]*/

    init() {
        bitString= bitfolge(id(this));
        /*print("Meine ID ist " + id(this));
        print("Meine Bitfolge ist " + bitString);
        print("erstes Bit: " + sub_str(bitString, 0, 1));*/
        int currentLevel;
        for(currentLevel = 0; currentLevel < limit; currentLevel++) {
            succPredList[currentLevel + "_succ0"] = null;
            succPredList[currentLevel + "_succ1"] = null;
            succPredList[currentLevel + "_pred0"] = null;
            succPredList[currentLevel + "_pred1"] = null;    
        }
    }
/* How to get to know new neighbors? When update succPredList */

    timeout() {
        /* ToDo: Wir müssen hier auch noch die Präfixübereinstimmung hier überall mit einbauen */

        /*print("timeout");*/
        /* Regel 1a (linearisieren) */
        node[] nearestLeft;
        node[] nearestRight;

        /*print(length(neighbors));*/

        tempArray <<<<;
        int currentLevel;
        if (deleted == true){
            return;
        }
        for(currentLevel=0; currentLevel<limit; currentLevel++)
        {
            sortedLeftNeighbors(currentLevel); /*tempArray wird mit sorted LeftNeighbors der richtigen Ebene gefüllt*/
            /*print("Laenge:");*/
            /*print(length(tempArray));*/
            int i;
            for(i=length(tempArray)-1; i > 1; i--){
                tempArray[i] -> linearize(tempArray[i-1]);
                if(tempArray[i-1] == null){
                    print("tempArray[i-1] is null with i = " + i);
                }
                /*tempArray[i] -> linearize(this);*/
            }
            if(tempArray[0] != null){
                tempArray[0] -> linearize(this); 
            }
            nearestLeft[currentLevel] = tempArray[0];

            tempArray <<<<;
            sortedRightNeighbors(currentLevel); /*tempArray wird mit sorted RightNeighbors der richtigen Ebene gefüllt*/

            int j;
            for(j= 0; j < length(tempArray)-1; j++){
                tempArray[j] -> linearize(tempArray[j+1]);
                if(tempArray[j+1] == null){
                    print("tempArray[j+1] is null with j = " + j);
                }
                /*tempArray[j] -> linearize(this);*/
            } 
            if(tempArray[length(tempArray)-1] != null){
                tempArray[length(tempArray)-1] -> linearize(this); 
            }
            nearestRight[currentLevel] = tempArray[length(tempArray)-1];
        }
        /* Für jeden i stellt u periodisch alle Knoten aus Ni(u) vor */
        /* Regel 1b */
        for(currentLevel=0; currentLevel<limit; currentLevel++)
        {
            tempArray <<<<;
            sortedLeftNeighbors(currentLevel); /*tempArray wird mit sorted LeftNeighbors der richtigen Ebene gefüllt*/
            int i;
            for(i=0; i< length(tempArray); i++){
                if(nearestRight[currentLevel] != null){
                    tempArray[i] -> linearize(nearestRight[currentLevel]);
                }
            }

            tempArray <<<<;
            sortedRightNeighbors(currentLevel); /*tempArray wird mit sorted RightNeighbors der richtigen Ebene gefüllt*/
            int j;
            for(j=0; j< length(tempArray); j++){
                if(nearestLeft[currentLevel] != null){
                    tempArray[j] -> linearize(nearestLeft[currentLevel]);
                }
            } 
            tempArray <<<<;
        }

        /* Hier rufen wir systematisch das linearize der nachbar knoten auf und stellen uns somit bei den Nachbarn vor */
    }
    linearize(node v){

       /* BREAKPOINT
        print(id(this));
        print(id(v)); */
        string vBit;
        vBit = bitfolge(id(v));

        int currentLevel = 0;

        [string, node] globalNewNeighbors;  /*[bitstring, node]*/


        if (deleted == true){
            return;
        }

        if (toBeDeleted[bitfolge(id(v))] == v){
            print("Node " + id(v) + " already forgotten");
            return;
        }

        if(v == null){
            print("Null Node linearized");
            return;
        }

        if(v == this){
            print("Self loop");
            return;
        }

        for(currentLevel = 0; currentLevel<limit; currentLevel++){
            /* if prefix is the same!!!*/
            
            if(checkIfNodeOnLevel(currentLevel, v) == true){  
                bool inRange;
                inRange = CheckIfNodeInRange(currentLevel, v); /* Weiß schon, ob Node in Range aufgenommen wird*/ 

                bool pred_0_is_null = (succPredList[currentLevel + "_pred0"] == null);
                bool pred_1_is_null = (succPredList[currentLevel + "_pred1"] == null);
                bool succ_0_is_null = (succPredList[currentLevel + "_succ0"] == null);
                bool succ_1_is_null = (succPredList[currentLevel + "_succ1"] == null);
                bool bit_after_prefix_is_0 = (integer(sub_str(vBit, currentLevel, currentLevel+1)) == 0);

                if (pred_0_is_null && bit_after_prefix_is_0 && (id(v) < id(this)) ){
                    succPredList[currentLevel + "_pred0"] = v;
                    neighbors[vBit] = v;
                    /*globalNewNeighbors[vBit] = v;*/
                }
                else if (pred_1_is_null && (!bit_after_prefix_is_0) && (id(v) < id(this)) ){
                    succPredList[currentLevel + "_pred1"] = v;
                    neighbors[vBit] = v;
                    /*globalNewNeighbors[vBit] = v;*/
                }
                else if (succ_0_is_null && bit_after_prefix_is_0 && (id(v) > id(this)) ){
                    succPredList[currentLevel + "_succ0"] = v;
                    neighbors[vBit] = v;
                    /*globalNewNeighbors[vBit] = v;*/
                }
                else if (succ_1_is_null && (!bit_after_prefix_is_0) && (id(v) > id(this)) ){
                    succPredList[currentLevel + "_succ1"] = v;
                    neighbors[vBit] = v;
                    /*globalNewNeighbors[vBit] = v;*/
                }
                else if (inRange){
                        /*vUsed = true;*/
                        /*print("else - ranges und nachbarschaften aktualisieren (succ, pred und nachbarschaftsliste))");*/
                        /*Nicht mehr gebrauchte Knoten weiterleiten*/
                        if (id(v) > id(this)){
                            if(integer(sub_str(vBit, currentLevel, currentLevel+1)) == 1){/*ist das i+1. bit eine 0 oder 1*/
                                if((id(v) < id(succPredList[currentLevel + "_succ1"]))){
                                    print("better succ_1 found: " + id(v) + " is new succ1 instead of " + id(succPredList[currentLevel + "_succ1"]));
                                    succPredList[currentLevel + "_succ1"] = v;/*wenn ja: v ist neuer succ*/
                                    neighbors[vBit] = v;
                                    /*globalNewNeighbors[vBit] = v;*/
                                }
                            }
                            else{
                                if(id(v) < id(succPredList[currentLevel + "_succ0"])){
                                    print("better succ_0 found: " + id(v) + " is new succ0 instead of " + id(succPredList[currentLevel + "_succ0"]));
                                    succPredList[currentLevel + "_succ0"] = v;/*wenn ja: v ist neuer succ*/
                                    neighbors[vBit] = v;
                                    /*globalNewNeighbors[vBit] = v;*/
                                }
                            }
                        }
                        if (id(v) < id(this)){
                            if(integer(sub_str(vBit, currentLevel, currentLevel+1)) == 1){/*ist das i+1. bit eine 0 oder 1*/
                                if((id(v) > id(succPredList[currentLevel + "_pred1"]))){
                                    print("better pred_1 found: " + id(v) + " is new pred_1 instead of " + id(succPredList[currentLevel + "_pred1"]));
                                    succPredList[currentLevel + "_pred1"] = v;/*wenn ja: v ist neuer pred, hier auch Neighbors hinzufügen!*/
                                    neighbors[vBit] = v;
                                    /*globalNewNeighbors[vBit] = v;*/
                                }
                            }
                            else{
                                if((id(v) > id(succPredList[currentLevel + "_pred0"]))){
                                    print("better pred_0 found: " + id(v) + " is new pred_0 instead of " + id(succPredList[currentLevel + "_pred0"]));
                                    succPredList[currentLevel + "_pred0"] = v;/*wenn ja: v ist neuer pred*/
                                    neighbors[vBit] = v;
                                    /*globalNewNeighbors[vBit] = v;*/
                                }
                            }
                    }
                }
                

                for (string bitString : node neighbor : neighbors){

                    inRange = CheckIfNodeInRange(currentLevel, neighbor);

                    if(neighbor == null){
                        print("NEEEEIIIIINNNNN");
                    }
                    /* Dieses hier hat auch keine stabilisierung gebracht. Können auch später wieder auf inRange ändern */
                    if(inRange || succPredList[currentLevel + "_pred0"] == neighbor || succPredList[currentLevel + "_pred1"] == neighbor || succPredList[currentLevel + "_succ0"] == neighbor || succPredList[currentLevel + "_succ1"] == neighbor){
                        globalNewNeighbors[bitString] = neighbor;
                    }
                }
            }

        }

        /*Alle Nachbarkknoten weiterleiten die wir oben rauslöschen */

        node[] toBeforwardedNodes;
        int numberOfNodes;
        numberOfNodes = 0;

        for (string bitString : node neighbor : neighbors){

            if(globalNewNeighbors[bitString] == null){
                toBeforwardedNodes[numberOfNodes] = neighbor;
                print("to be forwarded: " + id(neighbor));
                numberOfNodes++;
            }
        }

        neighbors <<<<; /*neighbors überschreiben*/
        for (string bitString : node neighbor : globalNewNeighbors){ 
            neighbors[bitString] = neighbor;
        }

        for (node oldNeighbor : toBeforwardedNodes){ /*alte nachbarn weiterleiten*/
            forwardNode_old(oldNeighbor);
        }

    }
    

    entry(node C) {
        linearize(C);
    }

    search(int searchedId){
        string bits;
        bits = bitfolge(searchedId);
        if(neighbors[bits] != null){
            print("Found: " + neighbors[bits]);
        } else {
            node longestCommonPrefixNode;
            longestCommonPrefixNode = getLongestCommonPrefixNode(bitString);
            longestCommonPrefixNode -> search(searchedId);
        }
    }

    forgetNode (node v){
        /*Flag für zukünftige linearize einstellen z.B. id -> deleted WIE MACHEN OHNE EDGES ZU ERSTELLEN?*/
        /*gesamte Listen durchgehen und rauslöschen*/

        /*Nachricht an Nachbarknoten weiterleiten - aber wann soll man da denn stoppen? Die nachricht soll ja nicht ewig im Umlauf sein - abfrage ob v schon vergessen ist am anfang*/
        
        if (deleted == true){
            return;
        }
        if (toBeDeleted[bitfolge(id(v))] == v){
            print("Node " + id(v) + " already forgotten");
            return;
        }
        print("Forget Node " + id(v));
        toBeDeleted[bitfolge((id(v)))] = v;
        int currentLevel;
        for(currentLevel = 0; currentLevel<limit; currentLevel++){
            if(succPredList[currentLevel + "_pred0"] == v){
                succPredList[currentLevel + "_pred0"] = null;
            }
            else if (succPredList[currentLevel + "_pred0"] != null){
                succPredList[currentLevel + "_pred0"] -> forgetNode(v);
            }
            if(succPredList[currentLevel + "_pred1"] == v){
                succPredList[currentLevel + "_pred1"] = null;
            }
            else if (succPredList[currentLevel + "_pred1"] != null){
                succPredList[currentLevel + "_pred1"] -> forgetNode(v);
            }
            if(succPredList[currentLevel + "_succ0"] == v){
                succPredList[currentLevel + "_succ0"] = null;
            }
            else if (succPredList[currentLevel + "_succ0"] != null){
                succPredList[currentLevel + "_succ0"] -> forgetNode(v); 
            }
            if(succPredList[currentLevel + "_succ1"] == v){
                succPredList[currentLevel + "_succ1"] = null;
            }
            else if (succPredList[currentLevel + "_succ1"] != null){
                succPredList[currentLevel + "_succ1"] -> forgetNode(v);
            }
        }

        for (string bitString : node neighbor : neighbors){ 
            if(neighbor == v){
                neighbors[bitString] = null;
            }
            else if (neighbor != null){
                neighbor -> forgetNode(v);
            }
            
        }

        /*Nachricht an Nachbarknoten weiterleiten - aber wann soll man da denn stoppen? Die nachricht soll ja nicht ewig im Umlauf sein - abfrage ob v schon vergessen ist am anfang*/
    }

    delete(){
        /*for ingoing edges*/
        int currentLevel;
        for(currentLevel = 0; currentLevel<limit; currentLevel++){
            if(succPredList[currentLevel + "_pred0"] != null){
                succPredList[currentLevel + "_pred0"] -> forgetNode(this);
            }
            if(succPredList[currentLevel + "_pred1"] != null){
                succPredList[currentLevel + "_pred1"] -> forgetNode(this);
            }
            if(succPredList[currentLevel + "_succ0"] != null){
                succPredList[currentLevel + "_succ0"] -> forgetNode(this);
            }
            if(succPredList[currentLevel + "_succ1"] != null){
                succPredList[currentLevel + "_succ1"] -> forgetNode(this);
            }
        }
        /*Muss hier eine Funktion an alle Nachbarn losgeschickt werden, damit die den Knoten vergessen & die nachbarn müssen die nachricht auch weiterleiten?*/
        /*for outgoing edges */
        deleted = true;
        neighbors <<<<;
        succPredList <<<<;
        /*unser prof hat gesagt, dass beim Skip plus graphen die Knoten den Graphen einfach verlassen können, weil er so gut vernetzt ist. aber wie mache ich das? Wie sorge ich dafür, dass auch die anderen Knoten ihn vergessen?*/
    }

    integer int (string x){
        if (x == "1"){  
            return 1;
        } else {
           return 0;
        }   
    }

    checkIfNodeOnLevel bool (int currentLevel, node v){
        int common_prefix_length;
        common_prefix_length = longestCommonPrefix(bitString, bitfolge(id(v)));
        if (common_prefix_length >= currentLevel){
            return true;
        }
        else {
            return false;
        }

    }

    bitfolge string (int x) {
        int prime = 97;
        int res = (x * 37 + 17) % prime;
        int bit = 0;
        string bits = "";
        int i = 0;
        for (i=0; i<limit; i++){
            bit = res%2;
            if (bit == 1){
                bits = "1" + bits;
            }
            else {
                bits = "0" + bits;
            }
            res = res/2;
        }
        return bits;
    }

    minPred node (int level){
        node pred0;
        node pred1;

        pred0 = succPredList[level + "_pred0"];
        pred1 = succPredList[level + "_pred1"];  

        if (pred0 == null && pred1 == null) {
            return null;
        }
        if (pred0 == null) {
            return pred1;
        }
        if (pred1 == null) {
            return pred0;
        }

        /* beide != null → nimm den mit kleinerer ID (weil kleinster Vorgänger) */
        if (id(pred0) < id(pred1)) {
            return pred0;
        } else {
            return pred1;
        }



        /* ToDo Hat es kaputt gemacht */
        /*
         if(pred0 == null && pred1 != null){
            return pred1;
        } else if (pred0 != null && pred1 == null){
            return pred0;
        } */
        /* 
        node minPred;
        if(id(pred0) < id(pred1)){
            minPred = pred0;
        } else {
            minPred = pred1;
        }*/
        /*print("min pred" + id(minPred));*/
       /*  return minPred;*/
    }

    globalMinPred node (){
        int currentLevel;
        node minPred;
        minPred = minPred(0);
        for(currentLevel=1; currentLevel<limit; currentLevel++){
            if (id(minPred) > id(minPred(currentLevel))){
                minPred = minPred(currentLevel);
            }
        }
        return minPred;
    }

    maxSucc node (int level){
        node succ0;
        node succ1;

        succ0 = succPredList[level + "_succ0"];
        succ1 = succPredList[level + "_succ1"];  
        
        node maxSucc;
        if(id(succ0) > id(succ1)){
            maxSucc = succ0;
        } else {
            maxSucc = succ1;
        }
        return maxSucc;
    }

    globalMaxSucc node (){
        int currentLevel;
        node maxSucc;
        maxSucc = maxSucc(0);
        for(currentLevel=1; currentLevel<limit; currentLevel++){
            if (id(maxSucc) < id(maxSucc(currentLevel))){
                maxSucc = maxSucc(currentLevel);
            }
        }
        return maxSucc;
    }

    longestCommonPrefix int(string bit1, string bit2) { 
        int i;
        int commonLength; 
        commonLength= 0;
        /*print(limit);*/

        for(i = 0; i < limit; i++){
            if(sub_str(bit1, i, i+1) == sub_str(bit2, i, i+1)){
                commonLength++;
            } else {
                break;
            }
        }
        return commonLength;
    }

    getLongestCommonPrefixNode node (string bitString){
        int longestCommonBits;
        node nextNode;
                
        longestCommonBits = -1;
        nextNode = null;
        for (string neighborBit : node neighbor : neighbors){
            if(bitString != neighborBit){
                int commonBits;
                commonBits = longestCommonPrefix(bitString, neighborBit);
                if(commonBits > longestCommonBits) {
                    longestCommonBits = commonBits;
                    nextNode = neighbor;
                }
            }
        }
        if (nextNode == null){
            print("nextNode is null");
        }
        return nextNode;
    }
    

    CheckIfNodeInRange bool (int currentLevel, node v){
        node minPred = minPred(currentLevel);
        node maxSucc = maxSucc(currentLevel);

        bool inRange;
        inRange = false;
            
        if ((minPred != null) && (maxSucc != null)){       
            bool biggerThanSucc;
            biggerThanSucc = false;
            bool smallerThanPred;
            smallerThanPred = false;

            /*Wichtif: > und < da sonst der maxSucc nicht in range ist*/
            if(id(v) > id(maxSucc)){
                biggerThanSucc = true;
            }
        
            if(id(v) < id(minPred)){
                smallerThanPred = true;
            }
            
            inRange = !(biggerThanSucc || smallerThanPred); 

            if(inRange == false && id(v) == 1){
               /*  print("v: " + id(v));
                print("minPred: " + id(minPred));
                print("maxSucc: " + id(maxSucc));*/
            }
        }
        else if ((minPred == null) && (maxSucc == null)){
            inRange = true;
        }
        else if ((minPred == null) && (maxSucc != null) && (id(v) <= id(maxSucc))){
            inRange = true;
        }
        else if ((minPred != null) && (maxSucc == null) && (id(v) >= id(minPred))){
            inRange = true;
        }
        return inRange;
    }

    forwardNode_old (node forwardedNode) {
        if (toBeDeleted[bitfolge(id(forwardedNode))] == forwardedNode){
            print("Node " + id(forwardedNode) + " already forgotten - do not forward");
            return;
        }
        node longestCommonPrefixNode; /*ich glaube das ergibt gar keinen sinn*/
        string bitString;
        bitString = bitfolge(id(forwardedNode));
        longestCommonPrefixNode = getLongestCommonPrefixNode(bitString);
        if(longestCommonPrefixNode != null){
            longestCommonPrefixNode -> linearize(forwardedNode);
            if(forwardedNode == null){
                print("forwardedNode is null");
            }
        } else {
            print("Neiiiin");
            /*Fallback */
            this -> linearize(forwardedNode); 
            /*wir sollten nie in den Fall kommen, da wir schon succ und pred auf null */
            /*Was tun wir wenn nextNode == null -> Dann haben wir problem -> dann müssen wir den aufnehen wenn wir noch keine nachbarn haben */
        }
    }

    forwardNode (node forwardedNode) {
        node next_node;
        if(forwardedNode == null){
                print("forwardedNode is null");
            }
        if (id(forwardedNode) < id(this)){
            next_node = globalMinPred();
            next_node -> linearize(forwardedNode);
        }
        else if (id(forwardedNode) > id(this)){
            next_node = globalMaxSucc();
            next_node -> linearize(forwardedNode);
        } else {
            /** TODo wir kommen in diesen fall -> Ist das schlimm? */
            /*print("gleicher Node???");*/
            /*wir sollten nie in den Fall kommen, da wir schon succ und pred auf null */
            /*Was tun wir wenn nextNode == null -> Dann haben wir problem -> dann müssen wir den aufnehen wenn wir noch keine nachbarn haben */
        }
    }

    sortedLeftNeighbors(int currentLevel){
        int i = 0;
        tempArray <<<<;
        for (string neighborBit : node neighbor : neighbors){
            if ((checkIfNodeOnLevel(currentLevel, neighbor))&&(id(neighbor) < id(this))){ /*collect smaller nodes*/
                tempArray[i] = neighbor;
                i = i+1;
            }
        }
        bubbleSort();
        /*
        int j;
        for (j = 0; j < length(tempArray); j++){ 
            print("Sorted Left Neighbor:" + id(tempArray[j]) + " " + j);
        }
            */
        return;
    }

    sortedRightNeighbors (int currentLevel){
        int i = 0;
        tempArray <<<<;
        for (string neighborBit : node neighbor : neighbors){
            if ((checkIfNodeOnLevel(currentLevel, neighbor))&&(id(neighbor) > id(this))){ /*collect bigger nodes on same level*/
                tempArray[i] = neighbor;
                i = i+1;
            }
        }
        bubbleSort();
        /*
        int j;
        for (j = 0; j < length(tempArray); j++){ 
            print("Sorted Right Neighbor:" + id(tempArray[j]) + " " + j);
        }
        */
        return;
    }

    bubbleSort () {
        int n;
        n = length(tempArray);
        int i;
        int j;
        node temp;
        for(i = 0; i < n-1; i++) {
            for(j = 0; j < n-i-1; j++) {
                if(id(tempArray[j]) > id(tempArray[j+1])) {
                    temp = tempArray[j];
                    tempArray[j] = tempArray[j+1];
                    tempArray[j+1] = temp;
                }
            }
        }
        return;
    }
}
