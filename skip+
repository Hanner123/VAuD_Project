succPredListclientNode{
    int limit = 5;
    string bitString;
    bool deleted = false;
    [string, node] succPredList;
    [string, node] neighbors;
    [string, node] toBeDeleted red; 
    [int, string] broadcast_messages;
    node[] tempArray;

    init() {
        bitString= bitfolge(id(this));
        int currentLevel;
        for(currentLevel = 0; currentLevel < limit; currentLevel++) {
            succPredList[currentLevel + "_succ0"] = null;
            succPredList[currentLevel + "_succ1"] = null;
            succPredList[currentLevel + "_pred0"] = null;
            succPredList[currentLevel + "_pred1"] = null;    
        }
    }

    timeout() {
        /*Debug*/
        /*
        if(id(this) == 1){
            int counter_3;
            for (string bitString : node neighbor : neighbors){
                if (id(neighbor) == 3){
                    print("!!!!!!!!!!!!!!!!!!!!Node 1 has neighbor 3!!!!!!!!!!!!!!!!!!!!!!!");
                    BREAKPOINT
                }
            }
            int level_test = 0;
            for(level_test = 0; level_test < limit; level_test++) {
                if(id(succPredList[level_test + "_succ0"]) == 1){
                    print("!!!!!!!!!!!!!!!!!!!!Node 1 has _succ0 3!!!!!!!!!!!!!!!!!!!!!!!");
                    BREAKPOINT
                }
                if(id(succPredList[level_test + "_succ1"]) == 1){
                   print("!!!!!!!!!!!!!!!!!!!!Node 1 has _succ1 3!!!!!!!!!!!!!!!!!!!!!!!");
                    BREAKPOINT
                }
                if(id(succPredList[level_test + "_pred0"]) == 1){
                    print("!!!!!!!!!!!!!!!!!!!!Node 1 has _pred0 3!!!!!!!!!!!!!!!!!!!!!!!");
                    BREAKPOINT
                }
                if(id(succPredList[level_test + "_pred1"]) == 1){
                    print("!!!!!!!!!!!!!!!!!!!!Node 1 has _pred1 3!!!!!!!!!!!!!!!!!!!!!!!");
                    BREAKPOINT
                }
            }
        }
        int level_test = 0;
        int counter_3 = 0;
        if(id(this) == 3){
            for(level_test = 0; level_test < limit; level_test++) {
                if(id(succPredList[level_test + "_succ0"]) == 1){
                    counter_3 = counter_3 + 1;
                }
                if(id(succPredList[level_test + "_succ1"]) == 1){
                    counter_3 = counter_3 + 1;
                }
                if(id(succPredList[level_test + "_pred0"]) == 1){
                    counter_3 = counter_3 + 1;
                }
                if(id(succPredList[level_test + "_pred1"]) == 1){
                    counter_3 = counter_3 + 1;
                }
            }
            for (string bitString : node neighbor : neighbors){
                if (id(neighbor) == 1){
                    counter_3 = counter_3 + 1;
                }
            }
            if (counter_3 > 2){
                print("!!!!!!!!!!!!!!!!!!!!Node 3 has three connections to 1!!!!!!!!!!!!!!!!!!!!!!!");
                BREAKPOINT
        
            }
        }
        */
        

        if (deleted == true){
            return;
        }

        /* Rule 1a */
        node[] nearestLeft;
        node[] nearestRight;

        tempArray <<<<; /*delete tempArray for sorted neighbors */

        int currentLevel;

        for(currentLevel = 0; currentLevel<limit; currentLevel ++)
        {
            /*Rule 1a*/
            /*Introduce left neighbors */
            sortedLeftNeighbors(currentLevel); /*leftNeighbors are sorted and copied into tempArray*/

            int i;
            for(i= length(tempArray) - 1; i > 0; i --){ /*größer 0, denn dann wird auch noch das letzte element der neighbors (an stelle 0) mit dem an stelle 1 verbunden*/
                tempArray[i] -> linearize(tempArray[i-1]);
                if(id(this) == 3){
                    print("linearize " + id(tempArray[i]) +" with " + id(tempArray[i-1]));
                }
            }
            if(tempArray[0] != null){
                tempArray[0] -> linearize(this); 
                if(id(this) == 3){
                    print("linearize " + id(tempArray[0]) +" with node 3");
                }
            }
            nearestLeft[currentLevel] = tempArray[0];
            
            /*Introduce right neighbors */
            tempArray <<<<; /*delete tempArray for sorted neighbors */
            sortedRightNeighbors(currentLevel); /*rightNeighbors are sorted and copied into tempArray*/

            int j;
            for(j= 0; j < length(tempArray)-1; j++){ /*length-1 ist das letzte element -> sollte passen*/
                tempArray[j] -> linearize(tempArray[j+1]);
            } 
            if(tempArray[length(tempArray) - 1] != null){
                tempArray[length(tempArray) - 1] -> linearize(this); 
            }
            nearestRight[currentLevel] = tempArray[length(tempArray)-1];
        }

        /* Rule 1b */
        for(currentLevel = 0; currentLevel < limit; currentLevel++)
        {
            tempArray <<<<; /*delete tempArray for sorted neighbors */
            sortedLeftNeighbors(currentLevel); /*leftNeighbors are sorted and copied into tempArray*/
            int i;
            for(i = 0; i< length(tempArray); i++){
                if(nearestRight[currentLevel] != null){
                    tempArray[i] -> linearize(nearestRight[currentLevel]);
                }
            }

            tempArray <<<<; /*delete tempArray for sorted neighbors */
            sortedRightNeighbors(currentLevel); /*rightNeighbors are sorted and copied into tempArray*/
            int j;
            for(j = 0; j < length(tempArray); j ++){
                if(nearestLeft[currentLevel] != null){
                    tempArray[j] -> linearize(nearestLeft[currentLevel]);
                }
            } 
            tempArray <<<<; /*delete tempArray for sorted neighbors */
        }
    }


    linearize(node v){
        if((id(this) == 1) && (id(v)==3)){
            print("linearize function at node 1 with node 3");
        }
        string vBit;
        vBit = bitfolge(id(v));

        int currentLevel = 0;

        [string, node] globalNewNeighbors; /* neighbors after linearize */

        if (deleted){
            return;
        }

        if (toBeDeleted[bitfolge(id(v))] == v){
            /*Deleted Node */
            return;
        }

        if(v == null){
            /*Null Node */
            return;
        }

        if(v == this){
            /*Self Node */
            return;
        }
        /*bool[] inRangeOnLevels; 
        for(currentLevel = 0; currentLevel<limit; currentLevel++){
            inRangeOnLevels[currentLevel] = true;
        }*/
        for(currentLevel = 0; currentLevel<limit; currentLevel++){
            if(checkIfNodeOnLevel(currentLevel, v)){  

                bool pred_0_is_null = (succPredList[currentLevel + "_pred0"] == null);
                bool pred_1_is_null = (succPredList[currentLevel + "_pred1"] == null);
                bool succ_0_is_null = (succPredList[currentLevel + "_succ0"] == null);
                bool succ_1_is_null = (succPredList[currentLevel + "_succ1"] == null);
                bool bit_after_prefix_is_0 = (integer(sub_str(vBit, currentLevel, currentLevel+1)) == 0);

                if (pred_0_is_null && bit_after_prefix_is_0 && (id(v) < id(this)) ){
                    succPredList[currentLevel + "_pred0"] = v;
                    neighbors[vBit] = v;
                }
                else if (pred_1_is_null && (!bit_after_prefix_is_0) && (id(v) < id(this)) ){
                    succPredList[currentLevel + "_pred1"] = v;
                    neighbors[vBit] = v;
                }
                else if (succ_0_is_null && bit_after_prefix_is_0 && (id(v) > id(this)) ){
                    succPredList[currentLevel + "_succ0"] = v;
                    neighbors[vBit] = v;
                }
                else if (succ_1_is_null && (!bit_after_prefix_is_0) && (id(v) > id(this)) ){
                    succPredList[currentLevel + "_succ1"] = v;
                    neighbors[vBit] = v;
                }
                else if (checkIfNodeInRange(currentLevel, v)){
                    /*if v is in range_i it has to be in the neighbor list -ZU VIELE NEIGHBORS (5 hat 1 als neighbor, falsch)*/
                    neighbors[vBit] = v;
                    /*decide if v should be in succPredList*/
                    if (id(v) > id(this)){
                        if(integer(sub_str(vBit, currentLevel, currentLevel+1)) == 1){/*check if the i+1. bit is a 0 or 1*/
                            if((id(v) < id(succPredList[currentLevel + "_succ1"]))){
                                print("better succ_1 found: " + id(v) + " is new succ1 instead of " + id(succPredList[currentLevel + "_succ1"]));
                                succPredList[currentLevel + "_succ1"] = v;/*v is new succ1*/
                            }
                        }
                        else{
                            if(id(v) < id(succPredList[currentLevel + "_succ0"])){
                                print("better succ_0 found: " + id(v) + " is new succ0 instead of " + id(succPredList[currentLevel + "_succ0"]));
                                succPredList[currentLevel + "_succ0"] = v;/*v is new succ0*/
                            }
                        }
                    }
                    if (id(v) < id(this)){
                        if(integer(sub_str(vBit, currentLevel, currentLevel+1)) == 1){/*check if the i+1. bit is a 0 or 1*/
                            if((id(v) > id(succPredList[currentLevel + "_pred1"]))){
                                print("better pred_1 found: " + id(v) + " is new pred_1 instead of " + id(succPredList[currentLevel + "_pred1"]));
                                succPredList[currentLevel + "_pred1"] = v;/*v is new pred1*/
                            }
                        }
                        else{
                            if((id(v) > id(succPredList[currentLevel + "_pred0"]))){
                                print("better pred_0 found: " + id(v) + " is new pred_0 instead of " + id(succPredList[currentLevel + "_pred0"]));
                                succPredList[currentLevel + "_pred0"] = v;/*v is new pred0*/
                            }
                        }
                    }
                }
                /*else{
                    inRangeOnLevels[currentLevel] = false;
                }*/
            }
            /*else{
                inRangeOnLevels[currentLevel] = false;
            }*/
        }
        /*Check if v is not in range on all levels (= is not recorded in neighbors) -> forward v*/

        
        if(neighbors[bitString] == null){
            print("node " + id(v) + " has to be forwarded.");
            forwardNode(v);
            return;
        }
            
        /*
        for(currentLevel = 0; currentLevel<limit; currentLevel++){
            if(inRangeOnLevels[currentLevel] == true){
                break;
            }
            if(currentLevel == limit -1){
                print("node " + id(v) + " has to be forwarded by node " + id(this));
                forwardNode(v);
                return;
            }
        }
        */


        /*Check which nodes are needed for the new neighbors map */
        for(currentLevel = 0; currentLevel<limit; currentLevel++){
            for (string bitString : node neighbor : neighbors){
                if(checkIfNodeOnLevel(currentLevel, neighbor)){
                    bool inRange;
                    inRange = checkIfNodeInRange(currentLevel, neighbor);

                    if(inRange && (neighbor != null)){ 
                        globalNewNeighbors[bitString] = neighbor;
                    }
                }
            }
        }

        /*Check which nodes can be forwarded of the old neighbors */
        node[] toBeforwardedNodes;
        int i = 0;
        for (string bitString : node neighbor : neighbors){
            if(neighbor != null && globalNewNeighbors[bitString] == null){
                toBeforwardedNodes[i] = neighbor;
                i++;
            }
        }

        neighbors <<<<; /*delete old neighbors*/
        /*Update neighbors */
        for (string bitString : node neighbor : globalNewNeighbors){ 
            neighbors[bitString] = neighbor;
        }

        /*Forward not necessary nodes */
        for (node oldNeighbor : toBeforwardedNodes){
            forwardNode(oldNeighbor);
        }
    }
    

    entry(node C) {
        linearize(C);
    }

    join(node C) {
        linearize(C);
    }

    search(int searchedId){
        if(searchedId == id(this)){
            /*node found*/
            print("Node " + id(this) + " found!");
            return;
        }
        node nextNeighbor;
        for (string bitString : node neighbor : neighbors){ 
            if(id(neighbor) == searchedId){
                nextNeighbor = neighbor; 
                break;
            }
            if(searchedId < id(this)){
                /*  go left*/
                if((id(neighbor) < id(this)) && (id(neighbor) > searchedId)){
                    if((nextNeighbor == null) || (id(neighbor) < id(nextNeighbor))){
                        nextNeighbor = neighbor;
                    } 
                }
            } else if (searchedId > id(this)){
                /* go right*/
                if((id(neighbor) > id(this)) && (id(neighbor) < searchedId)){
                    if((nextNeighbor == null) || (id(neighbor) > id(nextNeighbor))){
                        nextNeighbor = neighbor;
                    } 
                }
            }
        }
        if(nextNeighbor == null){
            print("Can not find node");
        } else {
            nextNeighbor -> search(searchedId);
        }
    }

    forgetNode (node v){
        if (deleted){
            return;
        }

        if (toBeDeleted[bitfolge(id(v))] == v){
            return;
        }
        toBeDeleted[bitfolge((id(v)))] = v;
        int currentLevel;

        for (string bitString : node neighbor : neighbors){ 
            if(neighbor == v){
                neighbors[bitString] = null;
            }
            else if (neighbor != null){
                neighbor -> forgetNode(v);
            }
            
        }
    }

    broadcast(string message, int message_id){
        /* Check if the message is already sent */
        if (broadcast_messages[message_id] == ""){
            print("Got Message: " + message);
            broadcast_messages[message_id] = message;        
            for(string bitString : node neighbor : neighbors){
                neighbor -> broadcast(message, message_id);
            }
        }
    }

    leave(){
        /*for ingoing edges*/
        for (string bitString : node neighbor : neighbors){ 
            neighbor -> forgetNode(this);
        }

        /*for outgoing edges */
        deleted = true;
        neighbors <<<<;
        succPredList <<<<;
    }

    /* convert bitstring to int */
    integer int (string x){
        if (x == "1"){  
            return 1;
        } else {
           return 0;
        }   
    }

    checkIfNodeOnLevel bool (int level, node v){
        /* check if at least level first bits are matching */
        int common_prefix_length;
        common_prefix_length = longestCommonPrefix(bitString, bitfolge(id(v)));
        if (common_prefix_length >= level){
            return true;
        }
        else {
            return false;
        }

    }

    bitfolge string (int x) {
        /* create pseudo random bitstring */
        int prime = 97;
        int res = (x * 37 + 17) % prime;
        int bit = 0;
        string bits = "";
        int i = 0;
        for (i = 0; i < limit; i++){
            bit = res % 2;
            if (bit == 1){
                bits = "1" + bits;
            }
            else {
                bits = "0" + bits;
            }
            res = res/2;
        }
        return bits;
    }

    minPred node (int level){
        /*determine whether pred0 or pred1 is min pred on current level*/
        node pred0;
        node pred1;

        pred0 = succPredList[level + "_pred0"];
        pred1 = succPredList[level + "_pred1"];  

        if (pred0 == null && pred1 == null) {
            return null;
        }
        if (pred0 == null) {
            return pred1;
        }
        if (pred1 == null) {
            return pred0;
        }

        if (id(pred0) < id(pred1)) {
            return pred0;
        } else {
            return pred1;
        }
    }

    globalMinPred node (){
        /*determine min pred over all levels*/
        int currentLevel;
        node minPred;
        minPred = minPred(0);
        for(currentLevel = 1; currentLevel < limit; currentLevel++){
            if (id(minPred) > id(minPred(currentLevel))){
                minPred = minPred(currentLevel);
            }
        }
        return minPred;
    }

    maxSucc node (int level){
        /*determine whether succ0 or succ1 is max succ on current level*/
        node succ0;
        node succ1;

        succ0 = succPredList[level + "_succ0"];
        succ1 = succPredList[level + "_succ1"];

        if (succ0 == null && succ1 == null) {
            return null;
        }
        if (succ0 == null) {
            return succ1;
        }
        if (succ1 == null) {
            return succ0;
        }

        if (id(succ0) > id(succ1)) {
            return succ0;
        } else {
            return succ1;
        }
    }

    globalMaxSucc node (){
        /*determine max succ over all levels*/
        int currentLevel;
        node maxSucc;
        maxSucc = maxSucc(0);
        for(currentLevel = 1; currentLevel < limit; currentLevel++){
            if (id(maxSucc) < id(maxSucc(currentLevel))){
                maxSucc = maxSucc(currentLevel);
            }
        }
        return maxSucc;
    }

    longestCommonPrefix int(string bit1, string bit2) {
        /* compute the length of the longest common prefix of two bitstrings */
        int i;
        int commonLength; 
        commonLength= 0;

        for(i = 0; i < limit; i++){
            if(sub_str(bit1, i, i+1) == sub_str(bit2, i, i+1)){
                commonLength++;
            } else {
                break;
            }
        }
        return commonLength;
    }

    getLongestCommonPrefixNode node (string bitString){
        /* determine the node of the neigbhours with the longest common prefix to the given bitstring */
        int longestCommonBits;
        node longestCommonPrefixNode;
        
        longestCommonBits = -1; /*-1 because a node with common prefix 0 could be the longest common prefix node */
        for (string neighborBit : node neighbor : neighbors){
            if(bitString != neighborBit){
                int commonBits;
                commonBits = longestCommonPrefix(bitString, neighborBit);
                if(commonBits > longestCommonBits) {
                    longestCommonBits = commonBits;
                    longestCommonPrefixNode = neighbor;
                }
            }
        }
        return longestCommonPrefixNode;
    }
    

    checkIfNodeInRange bool (int level, node v){
        /*check if node v is in range of this node on level */
        node minPred = minPred(level);
        node maxSucc = maxSucc(level);

        bool inRange;
        inRange = false;
            
        if ((minPred != null) && (maxSucc != null)){       
            bool biggerThanSucc;
            biggerThanSucc = false;
            bool smallerThanPred;
            smallerThanPred = false;

            /* > and < such that maxSucc/minPred is in range*/
            if(id(v) > id(maxSucc)){
                biggerThanSucc = true;
            }
        
            if(id(v) < id(minPred)){
                smallerThanPred = true;
            }
            
            inRange = !(biggerThanSucc || smallerThanPred); 
        }
        /*edge cases minPred and / or maxSucc null */
        else if ((minPred == null) && (maxSucc == null)){
            inRange = true;
        }
        else if ((minPred == null) && (maxSucc != null) && (id(v) <= id(maxSucc))){
            inRange = true;
        }
        else if ((minPred != null) && (maxSucc == null) && (id(v) >= id(minPred))){
            inRange = true;
        }
        return inRange;
    }

    forwardNode (node forwardedNode) {
        /*forward node to node with longest common prefix */
        if (toBeDeleted[bitfolge(id(forwardedNode))] == forwardedNode){
            return;
        }
        if(forwardedNode == null){
            return;
        }
        node longestCommonPrefixNode;
        string bitString;
        bitString = bitfolge(id(forwardedNode));
        longestCommonPrefixNode = getLongestCommonPrefixNode(bitString);
        longestCommonPrefixNode -> linearize(forwardedNode);
    }

    sortedLeftNeighbors(int level){
        /* write left neighbors of level in tempArray and sort it */
        int i = 0;
        tempArray <<<<;
        for (string neighborBit : node neighbor : neighbors){
            if ((checkIfNodeOnLevel(level, neighbor))&&(id(neighbor) < id(this))){ /*collect smaller nodes*/
                tempArray[i] = neighbor;
                i = i+1;
            }
        }
        /*debug*/
        if(level == 0){
            node[] checkArray;
            int ileft = 0;
            for (string neighborBit : node neighbor : neighbors){
                if (id(neighbor) < id(this)){ /*collect smaller nodes*/
                    checkArray[ileft] = neighbor;
                    ileft = ileft+1;
                }
            }
            int j = 0;
            if(length(checkArray) != length(tempArray)){
                for(j = 0; j < length(tempArray); j++){
                    print("tempArray[" + j + "]: " + id(tempArray[j]));
                }
                for(j = 0; j < length(checkArray); j++){
                    print("checkArray[" + j + "]: " + id(checkArray[j]));
                }
                print("length(checkArray): " + length(checkArray));
                print("length(tempArray): " + length(tempArray));
                print("Error in sortedLeftNeighbors at node " + id(this) + ": Not all left neighbors on level 0 collected!");
            }
            
        }
        bubbleSort();
        return;
    }

    sortedRightNeighbors (int level){
        /* write right neighbors of level in tempArray and sort it */
        int i = 0;
        tempArray <<<<;
        for (string neighborBit : node neighbor : neighbors){
            if ((checkIfNodeOnLevel(level, neighbor))&&(id(neighbor) > id(this))){ /*collect bigger nodes*/
                tempArray[i] = neighbor;
                i = i+1;
            }
        }
        /*debug*/
        if(level == 0){
            node[] checkArray;
            int iright = 0;
            for (string neighborBit : node neighbor : neighbors){
                
                if (id(neighbor) > id(this)){ /*collect smaller nodes*/
                    checkArray[iright] = neighbor;
                    iright = iright+1;
                }
            }
            int j = 0;
            if(length(checkArray) != length(tempArray)){
                for(j = 0; j < length(tempArray); j++){
                    print("tempArray[" + j + "]: " + id(tempArray[j]));
                }
                for(j = 0; j < length(checkArray); j++){
                    print("checkArray[" + j + "]: " + id(checkArray[j]));
                }
                print("length(checkArray): " + length(checkArray));
                print("length(tempArray): " + length(tempArray));
                print("Error in sortedRightNeighbors at node " + id(this) + ": Not all right neighbors on level 0 collected!");
            }
            
        }
        bubbleSort();
        return;
    }

    bubbleSort () {
        /*sort tempArray with bubble sort*/
        int n;
        n = length(tempArray);
        int i;
        int j;
        node temp;
        for(i = 0; i < n-1; i++) {
            for(j = 0; j < n-i-1; j++) {
                if(id(tempArray[j]) > id(tempArray[j+1])) {
                    temp = tempArray[j];
                    tempArray[j] = tempArray[j+1];
                    tempArray[j+1] = temp;
                }
            }
        }
        return;
    }
}
