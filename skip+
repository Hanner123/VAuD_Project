succPredListclientNode{
    int limit = 5;
    string bitString;
    [string, node] succPredList;
    [string, node] neighbors;  /*[bitstring, node]*/

    /* [0, 1, 2, 3, 4, 5][succ0, succ1, pred0, pred1][node] */
    /* [0_succ0, 0_succ1, 0_pred0, 0_pred1]*/

    init() {
        bitString= bitfolge(id(this));
        int currentLevel;
        for(currentLevel = 0; currentLevel < limit; currentLevel++) {
            succPredList[currentLevel + "_succ0"] = null;
            succPredList[currentLevel + "_succ1"] = null;
            succPredList[currentLevel + "_pred0"] = null;
            succPredList[currentLevel + "_pred1"] = null;    
        }
    }
/* How to get to know new neighbors? When update succPredList */

    timeout() {
        print("timeout");
        /* Regel 1a (linearisieren) */

        /* Für jeden i stellt u periodisch alle Knoten aus Ni(u) vor */
        /* Regel 1b */



        /* Hier rufen wir systematisch das linearize der nachbar knoten auf und stellen uns somit bei den Nachbarn vor */
    }
    linearize(node v){
        print("linearize");
        /* Regel 2 (überbrücken) */
        /* Hier erhalten wir die Vorgestellten Knoten und aktualisiern unsere Nachbarn / succPredList */

        /** 1. Aktualisiere Ranges und Nachbarschaft für jedes Level i */
        /** 2. Jeder Knoten w, der nun nicht mehr im range liegt -> delegieren (linearize bei anderem Knoten) zu Knoten mit größter Präfixübereinstimmung*/

        string vBit;
        vBit = bitfolge(id(v));

        bool vUsed;
        vUsed = false;

        int currentLevel = 0;

        for(currentLevel = 0; currentLevel<limit; currentLevel++){
            node minPred = minPred(currentLevel);
            node maxSucc = maxSucc(currentLevel);

            bool inRange;
            
            if ((minPred != null) && (maxSucc != null)){
                string minPredBit = bitfolge(id(minPred));
                string maxSuccBit = bitfolge(id(maxSucc));
                
                bool biggerThanSucc;
                bool smallerThanPred;
                
                biggerThanSucc = vIsBigger(vBit, maxSuccBit);
                smallerThanPred = vIsSmaller(vBit, minPredBit);
                inRange = !(biggerThanSucc || smallerThanPred);   
            }
            
            if(minPred==null){
                /*schaue ob es ein pred sein kann (muss kleiner sein als this)*/
                if (vIsSmaller(vBit, bitString)){
                    vUsed = true;
                    if(integer(sub_str(vBit, currentLevel+1, currentLevel+2)) == 1){/*ist das i+1. bit eine 0 oder 1*/
                        succPredList[currentLevel + "_pred1"] = v;/*wenn ja: v ist neuer pred, hier auch Neighbors hinzufügen!*/
                        neighbors[vBit] = v;
                    }
                    else{
                        succPredList[currentLevel + "_pred0"] = v;/*wenn ja: v ist neuer pred*/
                        neighbors[vBit] = v;
                    }
                }
                else{
                    /*wenn nein: KP*/
                    inRange = false;
                }
                
            }
            if(maxSucc==null){
                /*schaue ob es ein succ sein kann (muss größer sein als this)*/
                if (vIsBigger(vBit, bitString)){
                    vUsed = true;
                    if(integer(sub_str(vBit, currentLevel+1, currentLevel+2)) == 1){/*ist das i+1. bit eine 0 oder 1*/
                        succPredList[currentLevel + "_succ1"] = v;/*wenn ja: v ist neuer succ*/
                        neighbors[vBit] = v;
                    }
                    else{
                        succPredList[currentLevel + "_succ0"] = v;/*wenn ja: v ist neuer succ*/
                        neighbors[vBit] = v;
                    }
                }
                else{
                    /*wenn nein: KP*/
                    inRange = false;
                }
            }


            if(inRange){
                vUsed = true;
                print("else - ranges und nachbarschaften aktualisieren (succ, pred und nachbarschaftsliste))");
                /*Nicht mehr gebrauchte Knoten weiterleiten*/
                if (vIsBigger(vBit, bitString)){
                    if(integer(sub_str(vBit, currentLevel+1, currentLevel+2)) == 1){/*ist das i+1. bit eine 0 oder 1*/
                        /*Welche Knoten gehören nicht mehr zur neighbor (in die range)*/
                        // pro ebene hinzufügen was wir nicht mehr brauchen

                        /*global (über alle ebenen): die Knoten, die in keiner neighbor liste sind deligieren und streichen*/
                        
                        succPredList[currentLevel + "_succ1"] = v;/*wenn ja: v ist neuer succ*/
                        neighbors[vBit] = v;
                    }
                    else{
                        succPredList[currentLevel + "_succ0"] = v;/*wenn ja: v ist neuer succ*/
                        neighbors[vBit] = v;
                    }
                    /*ist der neue succ dann der max succ? */
                    /*wenn ja: weiter entfernte Knoten deligieren */
                }
                if (vIsSmaller(vBit, bitString)){
                    if(integer(sub_str(vBit, currentLevel+1, currentLevel+2)) == 1){/*ist das i+1. bit eine 0 oder 1*/
                        succPredList[currentLevel + "_pred1"] = v;/*wenn ja: v ist neuer pred, hier auch Neighbors hinzufügen!*/
                        neighbors[vBit] = v;
                    }
                    else{
                        succPredList[currentLevel + "_pred0"] = v;/*wenn ja: v ist neuer pred*/
                        neighbors[vBit] = v;
                    }
                    /*ist der neue pred dann der min pred? */
                    /*wenn ja: weiter entfernte Knoten deligieren (bzw. ins array zum deligieren aufnehmen) */
                }
                /*globalen min_pred und max succ bestimmen (in der schleife oder danach) und dann löschen/deligieren?*/
                /*innerhalb der range - also ranges und nachbarschaften aktualisieren!*/
            }

        }
        
        /*Alle nnachbarkknoten weiterleiten die wir oben rauslöschen */

        if(!vUsed){
            /* Weiterleiten von v */
            node nextNode;
            nextNode = getLongestCommonPrefixNode(vBit);
            if(nextNode != null){
                nextNode -> linearize(v);
            } else {
                /*wir sollten nie in den Fall kommen, da wir schon succ und pred auf null */
                /*Was tun wir wenn nextNode == null -> Dann haben wir problem -> dann müssen wir den aufnehen wenn wir noch keine nachbarn haben */
            }
        }
            
    }
    

    entry(node C) {
        linearize(C);
    }

    integer int (string x){
        if (x == "1"){  
            return 1;
        } else {
           return 0;
        }   
    }


    bitfolge string (int x) {
        int prime = 97;
        int res = (x * 37 + 17) % prime;
        int bit = 0;
        string bits = "";
        int i = 0;
        for (i=0; i<limit; i++){
            bit = res%2;
            if (bit == 1){
                bits = "1" + bits;
            }
            else {
                bits = "0" + bits;
            }
        }
        return bits;
    }

    minPred node (int level){
        node pred0;
        node pred1;

        pred0 = succPredList[level + "_pred0"];
        pred1 = succPredList[level + "_pred1"];  
        
        node minPred;
        if(id(pred0) < id(pred1)){
     
           minPred = pred0;
        } else {
            minPred = pred1;
        }
        print("min pred" + id(minPred));
        return minPred;
    }

    maxSucc node (int level){
        node succ0;
        node succ1;

        succ0 = succPredList[level + "_succ0"];
        succ1 = succPredList[level + "_succ1"];  
        
        node maxSucc;
        if(id(succ0) > id(succ1)){
            maxSucc = succ0;
        } else {
            maxSucc = succ1;
        }
        print("max succ" + id(maxSucc));
        return maxSucc;
    }

    vIsSmaller bool (string vBit, string pred){
        int j;
        bool smallerThanPred;
        smallerThanPred = false;

        for(j=0; j<limit; j++){
            if (integer(sub_str(vBit, j, j+1)) < integer(sub_str(pred, j, j+1))){
                smallerThanPred = true;
                print(j);
                print("v is smaller");
                return true;
            }
        }
        return false;
    }

    vIsBigger bool (string vBit, string succ){
        int j;
        bool biggerThanSucc;
        biggerThanSucc = false;

        for(j=0; j<limit; j++){
            if (integer(sub_str(vBit, j, j+1)) > integer(sub_str(succ, j, j+1))){
                biggerThanSucc = true;
                print(j);
                print("v is bigger");
                return true;
            }
        }
        return false;
    }

    longestCommonPrefix int(string bit1, string bit2) { 
        int i;
        int commonLength; 
        commonLength= 0;
        print(limit);

        for(i = 0; i < limit; i++){
            if(sub_str(bit1, i, i+1) == sub_str(bit2, i, i+1)){
                commonLength++;
            } else {
                break;
            }
        }

        return commonLength;
    }

    getLongestCommonPrefixNode node (string wBit){
        int longestCommonBits;
        node nextNode;
                
        longestCommonBits = -1;
        nextNode = null;
        for (string neighborBit : node neighbor : neighbors){
            if(wBit != neighborBit){
                int commonBits;
                commonBits = longestCommonPrefix(wBit, neighborBit);
                if(commonBits > longestCommonBits) {
                    longestCommonBits = commonBits;
                    nextNode = neighbor;
                }
            }
        }
        return nextNode;
    }
    
    
}
